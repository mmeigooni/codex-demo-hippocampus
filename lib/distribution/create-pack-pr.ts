import { Octokit } from "octokit";

interface CreatePackPRInput {
  token: string;
  owner: string;
  repo: string;
  defaultBranch: string;
  markdownContent: string;
  commitMessage?: string;
  prTitle?: string;
  prBody?: string;
}

interface CreatePackPRResult {
  prNumber: number;
  prUrl: string;
  branch: string;
  sha: string;
}

const PACK_PATH = ".codex/team-memory.md";

function createGitHubClient(token: string) {
  return new Octokit({
    auth: token,
    userAgent: "hippocampus/0.1.0",
  });
}

function parseGitHubError(error: unknown): Error {
  if (typeof error === "object" && error && "message" in error) {
    const withMessage = error as { message: string; status?: number };
    const statusSuffix = withMessage.status ? ` (status ${withMessage.status})` : "";
    return new Error(`GitHub API request failed${statusSuffix}: ${withMessage.message}`);
  }

  return new Error("GitHub API request failed");
}

function countPattern(content: string, pattern: RegExp) {
  const matches = content.match(pattern);
  return matches?.length ?? 0;
}

function defaultPRBody(markdownContent: string) {
  const rulesPromoted = countPattern(markdownContent, /^### /gm);
  const contradictions = countPattern(markdownContent, /^- ! /gm);
  const generatedAt = new Date().toISOString();

  return [
    "This PR updates `.codex/team-memory.md` with the latest Hippocampus distribution pack.",
    "",
    `- Rules promoted: ${rulesPromoted}`,
    `- Contradictions: ${contradictions}`,
    `- Generated at: ${generatedAt}`,
    "",
    "Generated by Hippocampus.",
  ].join("\n");
}

async function maybeGetExistingFileSha({
  octokit,
  owner,
  repo,
  branch,
}: {
  octokit: Octokit;
  owner: string;
  repo: string;
  branch: string;
}) {
  try {
    const response = await octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
      owner,
      repo,
      path: PACK_PATH,
      ref: branch,
    });

    if (Array.isArray(response.data)) {
      return null;
    }

    return response.data.sha;
  } catch (error) {
    const withStatus = error as { status?: number };
    if (withStatus.status === 404) {
      return null;
    }

    throw error;
  }
}

export async function createPackPR(input: CreatePackPRInput): Promise<CreatePackPRResult> {
  const octokit = createGitHubClient(input.token);
  const branch = `hippocampus/team-memory-${Date.now()}`;

  try {
    const headRef = await octokit.request("GET /repos/{owner}/{repo}/git/ref/heads/{ref}", {
      owner: input.owner,
      repo: input.repo,
      ref: input.defaultBranch,
    });

    const headSha = headRef.data.object.sha;

    await octokit.request("POST /repos/{owner}/{repo}/git/refs", {
      owner: input.owner,
      repo: input.repo,
      ref: `refs/heads/${branch}`,
      sha: headSha,
    });

    const existingSha = await maybeGetExistingFileSha({
      octokit,
      owner: input.owner,
      repo: input.repo,
      branch,
    });

    const commitResponse = await octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", {
      owner: input.owner,
      repo: input.repo,
      path: PACK_PATH,
      message: input.commitMessage ?? "chore(hippocampus): update team memory pack",
      content: Buffer.from(input.markdownContent, "utf8").toString("base64"),
      branch,
      sha: existingSha ?? undefined,
    });

    const pullResponse = await octokit.request("POST /repos/{owner}/{repo}/pulls", {
      owner: input.owner,
      repo: input.repo,
      title: input.prTitle ?? "[Hippocampus] Update team memory pack",
      body: input.prBody ?? defaultPRBody(input.markdownContent),
      base: input.defaultBranch,
      head: branch,
    });

    const commitSha = commitResponse.data.commit.sha;
    const prUrl = pullResponse.data.html_url;

    if (!commitSha || !prUrl) {
      throw new Error("GitHub API response missing commit SHA or PR URL");
    }

    return {
      prNumber: pullResponse.data.number,
      prUrl,
      branch,
      sha: commitSha,
    };
  } catch (error) {
    throw parseGitHubError(error);
  }
}

export type { CreatePackPRInput, CreatePackPRResult };
