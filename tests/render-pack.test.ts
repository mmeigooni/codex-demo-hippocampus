import { describe, expect, it } from "vitest";

import type { ConsolidationModelOutput } from "@/lib/codex/types";
import { renderPackToMarkdown } from "@/lib/distribution/render-pack";

const fullPack: ConsolidationModelOutput = {
  patterns: [
    {
      name: "retry-cascade",
      episode_ids: ["ep-1", "ep-2"],
      summary: "Retry handling issues repeated across incidents.",
    },
  ],
  rules_to_promote: [
    {
      rule_key: "retry-strategy",
      title: "Always cap retries",
      description: "Use bounded exponential backoff for external calls.",
      triggers: ["retry", "setTimeout", "backoff"],
      source_episode_ids: ["ep-1", "ep-2"],
    },
  ],
  contradictions: [
    {
      left_episode_id: "ep-3",
      right_episode_id: "ep-4",
      reason: "Conflicting guidance on queue visibility timeout",
    },
  ],
  salience_updates: [
    {
      episode_id: "ep-1",
      salience_score: 9,
      reason: "Recurring high-impact outage pattern",
    },
  ],
  prune_candidates: ["ep-9"],
};

describe("renderPackToMarkdown", () => {
  it("renders full packs with all sections", () => {
    const markdown = renderPackToMarkdown(fullPack, "acme/shopflow", "2026-02-08T00:00:00.000Z");

    expect(markdown).toContain("# Team Memory Pack - acme/shopflow");
    expect(markdown).toContain("## Promoted Rules");
    expect(markdown).toContain("### Always cap retries");
    expect(markdown).toContain("**Rule key:** retry-strategy");
    expect(markdown).toContain("## Contradictions");
    expect(markdown).toContain("Episodes: ep-3 <-> ep-4");
    expect(markdown).toContain("## Salience Updates");
    expect(markdown).toContain("- ep-1 -> 9 (Recurring high-impact outage pattern)");
    expect(markdown).toContain("## Pruning Candidates");
    expect(markdown).toContain("- ep-9");
  });

  it("renders None placeholders for empty sections", () => {
    const emptyPack: ConsolidationModelOutput = {
      patterns: [],
      rules_to_promote: [],
      contradictions: [],
      salience_updates: [],
      prune_candidates: [],
    };

    const markdown = renderPackToMarkdown(emptyPack, "acme/empty-repo", "2026-02-08T00:00:00.000Z");

    expect(markdown).toContain("## Promoted Rules\nNone");
    expect(markdown).toContain("## Contradictions\nNone");
    expect(markdown).toContain("## Salience Updates\nNone");
    expect(markdown).toContain("## Pruning Candidates\nNone");
  });

  it("renders single-rule packs with other sections empty", () => {
    const singleRulePack: ConsolidationModelOutput = {
      patterns: [],
      rules_to_promote: [fullPack.rules_to_promote[0]],
      contradictions: [],
      salience_updates: [],
      prune_candidates: [],
    };

    const markdown = renderPackToMarkdown(singleRulePack, "acme/rule-only");

    expect(markdown).toContain("### Always cap retries");
    expect(markdown).toContain("## Contradictions\nNone");
    expect(markdown).toContain("## Salience Updates\nNone");
    expect(markdown).toContain("## Pruning Candidates\nNone");
  });

  it("normalizes newlines in special-character strings", () => {
    const specialPack: ConsolidationModelOutput = {
      ...fullPack,
      rules_to_promote: [
        {
          ...fullPack.rules_to_promote[0],
          description: "Line one\nLine two",
          triggers: ["retry\nloop", "caps"],
        },
      ],
    };

    const markdown = renderPackToMarkdown(specialPack, "acme/special");

    expect(markdown).toContain("Line one Line two");
    expect(markdown).toContain("**Triggers:** retry loop, caps");
  });

  it("uses provided timestamps in header text", () => {
    const generatedAt = "2026-02-08T01:02:03.000Z";
    const markdown = renderPackToMarkdown(fullPack, "acme/shopflow", generatedAt);

    expect(markdown).toContain(`Auto-generated by Hippocampus on ${generatedAt}`);
  });
});
